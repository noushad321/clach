(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["module-fixit-trigger"],{

/***/ "./cartridges/app_accelerator_core/cartridge/client/default/js/modules/module.fixit-trigger.js":
/*!*****************************************************************************************************!*\
  !*** ./cartridges/app_accelerator_core/cartridge/client/default/js/modules/module.fixit-trigger.js ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return FixitTrigger; });\n/* harmony import */ var _borngroup_born_fixit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @borngroup/born-fixit */ \"./node_modules/@borngroup/born-fixit/dist/born-fixit.min.js\");\n/* harmony import */ var _borngroup_born_fixit__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_borngroup_born_fixit__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _borngroup_born_utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @borngroup/born-utilities */ \"./node_modules/@borngroup/born-utilities/dist/born-utilities.min.js\");\n/* harmony import */ var _borngroup_born_utilities__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_borngroup_born_utilities__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _helpers_utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/utilities */ \"./cartridges/app_accelerator_core/cartridge/client/default/js/helpers/utilities.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * Fixit Trigger\n *\n * This module is a wrapper around born-fixit to allow the use of [data-fixit-trigger]\n * attribute on any element.\n *\n * see ../helpers/modules.js for \"fixit\" module initialization\n */\n\n\n\n\nvar FixitTrigger = /*#__PURE__*/function () {\n  function FixitTrigger(options) {\n    _classCallCheck(this, FixitTrigger);\n\n    options.settings = options.settings || {};\n    this.settingsAttribute = options.settings.settingsAttribute || 'data-fixit-trigger';\n    Object(_borngroup_born_utilities__WEBPACK_IMPORTED_MODULE_1__[\"callbackOnElements\"])(options.elements, this.setupFixitElements.bind(this, options.settings));\n  }\n  /**\n   * Parses the provided `fixitNode` element and tries to find a `this.settingsAttribute` configuration.\n   * The configuration is parsed and merged against an optional `settings` object that can be passed to the constructor.\n   */\n\n\n  _createClass(FixitTrigger, [{\n    key: \"setupFixitElements\",\n    value: function setupFixitElements(settings, fixitNode) {\n      var parsedOptions = JSON.parse(fixitNode.getAttribute(this.settingsAttribute)) || {}; // In this module scenario, target will always be fixitNode.\n\n      parsedOptions.target = fixitNode;\n      parsedOptions.enabled = parsedOptions.enabled ? FixitTrigger.isEnabled.bind(this, parsedOptions.enabled) : undefined;\n      parsedOptions.respondToParent = this.getElement(parsedOptions.respondToParent);\n      parsedOptions.containedInParent = this.getElement(parsedOptions.containedInParent);\n      fixitNode.removeAttribute(this.settingsAttribute);\n      new _borngroup_born_fixit__WEBPACK_IMPORTED_MODULE_0___default.a(Object(_helpers_utilities__WEBPACK_IMPORTED_MODULE_2__[\"objectAssign\"])({}, settings, parsedOptions));\n\n      if (parsedOptions.dynamicOffset) {\n        this.setupDynamicOffset(fixitNode, parsedOptions.dynamicOffset);\n      }\n    }\n  }, {\n    key: \"getElement\",\n    value: function getElement(elSelector) {\n      return typeof elSelector === 'string' ? document.querySelector(elSelector) : elSelector;\n    }\n    /**\n     * Configure a dynamic offset element,\n     * which uses FixIt's API to toggle the offset value in the current fixit-trigger node.\n     */\n\n  }, {\n    key: \"setupDynamicOffset\",\n    value: function setupDynamicOffset(fixitNode, offsetSelector) {\n      this.getElement(offsetSelector).addEventListener('fixit:scrollDirectionUpdate', function (evt) {\n        var currentInstance = _borngroup_born_fixit__WEBPACK_IMPORTED_MODULE_0___default.a.getInstance(fixitNode);\n\n        if (!currentInstance.isFrozen && !currentInstance.isDocked) {\n          if (evt.detail.newDirection === 'up' && evt.detail.previousDirection) {\n            currentInstance.setOffsetElements(offsetSelector);\n            currentInstance.setOffsetValue();\n          } else {\n            currentInstance.offset = 0;\n          }\n\n          currentInstance.setTargetPos(currentInstance.offset === 0);\n        }\n      });\n    }\n    /**\n     * Determines wether or not Fixit should be enabled.\n     * This method is called within Fixit on init and resize.\n     * Leverages `breakpointRanges` to match agains the `breakpointName` value.\n     * @return {Boolean}                [description]\n     */\n\n  }], [{\n    key: \"isEnabled\",\n    value: function isEnabled(breakpointName) {\n      var matchedBreakpoint = _helpers_utilities__WEBPACK_IMPORTED_MODULE_2__[\"breakpointRanges\"][breakpointName];\n      return matchedBreakpoint && (!matchedBreakpoint.min || document.body.offsetWidth >= matchedBreakpoint.min) && (!matchedBreakpoint.max || document.body.offsetWidth <= matchedBreakpoint.max);\n    }\n  }]);\n\n  return FixitTrigger;\n}();\n\n\n\n//# sourceURL=webpack:///./cartridges/app_accelerator_core/cartridge/client/default/js/modules/module.fixit-trigger.js?");

/***/ }),

/***/ "./node_modules/@borngroup/born-fixit/dist/born-fixit.min.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@borngroup/born-fixit/dist/born-fixit.min.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar PROPERTIES = {\n  direction: {\n    up: \"up\",\n    down: \"down\"\n  }\n},\n    INSTANCES = new Map();\n\nvar FixIt = function () {\n  function FixIt() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, FixIt);\n\n    this.options = options;\n\n    this.shouldEnable = this.options.enabled || function () {\n      return true;\n    };\n\n    this.target = (typeof this.options.target === \"string\" ? document.querySelector(this.options.target) : this.options.target) || false;\n\n    if (this.options.offset && isNaN(this.options.offset)) {\n      this.setOffsetElements();\n      this.setOffsetValue();\n    } else {\n      this.offset = this.options.offset || 0;\n    }\n\n    this._scrollDirectionWait = this.options.scrollDirectionWait || 100;\n    this._scrollPositionThereshold = this.options.scrollPositionThereshold || 75;\n    this._scrollDirectionThrottle = this.options.scrollDirectionThrottle || 16;\n    this._boundUpdateStickyStatus = this.updateStickyStatus.bind(this);\n    this._boundEnableSticky = this.enableSticky.bind(this, 150);\n\n    if (this.target) {\n      this.enableSticky();\n      window.addEventListener(\"resize\", this._boundEnableSticky);\n    }\n\n    INSTANCES.set(this.target, this);\n  }\n\n  _createClass(FixIt, [{\n    key: \"enableSticky\",\n    value: function enableSticky(timeOut) {\n      window.clearTimeout(this._resizeTimeout);\n      this._resizeTimeout = window.setTimeout(function () {\n        this.setOffsetValue();\n\n        if (!this.isEnabled && this.shouldEnable()) {\n          this.isEnabled = true;\n\n          if (!this.placeholder) {\n            this.initialSetup();\n          }\n\n          this._updateInterval = window.setInterval(this._boundUpdateStickyStatus.bind(this, true), 100);\n          window.addEventListener(\"scroll\", this._boundUpdateStickyStatus);\n\n          this._boundUpdateStickyStatus();\n        } else if (this.isEnabled && !this.shouldEnable()) {\n          this.isEnabled = false;\n          this.setInactive();\n          window.clearInterval(this._updateInterval);\n          window.removeEventListener(\"scroll\", this._boundUpdateStickyStatus);\n        }\n      }.bind(this), timeOut || 0);\n    }\n  }, {\n    key: \"destroySticky\",\n    value: function destroySticky() {\n      this.isEnabled = false;\n      this.setInactive();\n      this.removePlaceholder();\n      window.clearTimeout(this._resizeTimeout);\n      window.clearInterval(this._updateInterval);\n      window.removeEventListener(\"resize\", this._boundEnableSticky);\n      window.removeEventListener(\"scroll\", this._boundUpdateStickyStatus);\n    }\n  }, {\n    key: \"setOffsetValue\",\n    value: function setOffsetValue() {\n      var resultSum = 0;\n\n      if (this.offsetElements instanceof NodeList) {\n        [].forEach.call(this.offsetElements, function (currentEl) {\n          resultSum += Math.round(currentEl.getBoundingClientRect().height);\n        });\n      } else {\n        resultSum = this.offset || 0;\n      }\n\n      return this.offset = resultSum;\n    }\n  }, {\n    key: \"setOffsetElements\",\n    value: function setOffsetElements(offset) {\n      offset = offset || this.options.offset;\n      return this.offsetElements = typeof offset === \"string\" ? document.querySelectorAll(offset) : offset;\n    }\n  }, {\n    key: \"initialSetup\",\n    value: function initialSetup() {\n      this.setPlaceholder();\n      this.parentContainer = this.options.containedInParent ? this.options.containedInParent instanceof HTMLElement ? this.options.containedInParent : this.target.parentNode : false;\n\n      if (this.options.respondToParent) {\n        this.target.classList.add(\"fixit--respond-to-parent\");\n        this.options.respondToParent = this.options.respondToParent instanceof HTMLElement ? this.options.respondToParent : this.parentContainer;\n        window.addEventListener(\"resize\", this.respondTo.bind(this));\n        this.target.addEventListener(\"fixit:triggerResize\", this.respondTo.bind(this));\n      }\n\n      this.scrollPosition = 0;\n      this.publishEvent(\"fixit\", \"init\", this.target, {\n        FixIt: this\n      });\n\n      if (typeof this.options.onInitCallback === \"function\") {\n        this.options.onInitCallback(this.target, this);\n      }\n\n      this.target.addEventListener(\"fixit:updateScrollDirection\", function (evt) {\n        this.updateScrollDirection(evt.detail.scrollDirection);\n      }.bind(this));\n    }\n  }, {\n    key: \"updateStickyStatus\",\n    value: function updateStickyStatus(isAutoUpdate) {\n      isAutoUpdate = typeof isAutoUpdate === \"boolean\" ? isAutoUpdate : false;\n\n      if (!isAutoUpdate || isAutoUpdate && this._previousDocumentHeight !== this.getDocumentHeight()) {\n        this.setRectangles();\n        this._scrollListeningStart = this.options.fromViewportBottom ? this._placeholderRect.top + this._targetRect.height - Math.max(window.innerHeight, document.documentElement.clientHeight) : this._placeholderRect.top;\n\n        if ((!this.parentContainer || this._targetRect.height < this._parentContainerRect.height) && this._scrollListeningStart < this.offset) {\n          this.getScrollDirection();\n          this._previousDocumentHeight = this.getDocumentHeight();\n          this.toggletFullyScrolled(this._placeholderRect.top + this._targetRect.height < this.offset);\n\n          if (this.options.enableDirectionUpdates) {\n            this.requestScrollDirectionUpdate(this.currentScrollDirection);\n          }\n\n          if (!this.targetIsTall()) {\n            this.unsetIsTall();\n\n            if (!this.isActive) {\n              this.setActive();\n            }\n          } else {\n            this.setIsTall();\n\n            if (this.currentScrollDirection === PROPERTIES.direction.down) {\n              if (Math.round(this._targetRect.bottom) <= Math.max(window.innerHeight, document.documentElement.clientHeight)) {\n                if (!this.isActive) {\n                  this.isFrozen = false;\n                  this.setActive(true);\n                }\n              } else if (this.isActive && !this.isDocked && !this.shouldDock()) {\n                this.isActive = false;\n                this.setFrozen();\n                this.unsetBottom();\n              }\n            } else {\n              if (Math.round(this._targetRect.top) >= this.offset) {\n                if (!this.isActive) {\n                  this.isFrozen = false;\n                  this.setActive();\n                }\n              } else if (this.isActive && !this.isDocked && !this.shouldDock()) {\n                this.isActive = false;\n                this.setFrozen();\n                this.unsetBottom();\n              }\n            }\n          }\n\n          this.containInParent();\n        } else if (this.isActive) {\n          this.setInactive();\n        }\n      }\n\n      return this.isActive || this.isFrozen;\n    }\n  }, {\n    key: \"setRectangles\",\n    value: function setRectangles() {\n      this._targetRect = this.target.getBoundingClientRect();\n      this._placeholderRect = this.placeholder.getBoundingClientRect();\n      this._parentContainerRect = this.parentContainer ? this.parentContainer.getBoundingClientRect() : {};\n    }\n  }, {\n    key: \"getDocumentHeight\",\n    value: function getDocumentHeight() {\n      return Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight);\n    }\n  }, {\n    key: \"containInParent\",\n    value: function containInParent() {\n      if (this.parentContainer && this.isActive) {\n        this.setRectangles();\n\n        if (this.shouldDock()) {\n          this.setDocked();\n        } else if (this.isDocked && this._targetRect.top >= this.offset) {\n          this.setUndocked();\n        }\n      }\n    }\n  }, {\n    key: \"shouldDock\",\n    value: function shouldDock() {\n      return this._parentContainerRect.bottom <= document.documentElement.clientHeight && this._targetRect.bottom >= this._parentContainerRect.bottom && (this.isBottom || this._targetRect.top <= this.offset);\n    }\n  }, {\n    key: \"setDocked\",\n    value: function setDocked() {\n      this.isDocked = true;\n      this.target.classList.add(\"fixit--docked\");\n      this.unsetBottom();\n      this.setTargetPos(true);\n    }\n  }, {\n    key: \"setUndocked\",\n    value: function setUndocked() {\n      this.isDocked = false;\n      this.target.classList.remove(\"fixit--docked\");\n      this.setTargetPos();\n    }\n  }, {\n    key: \"setTargetPos\",\n    value: function setTargetPos(reset) {\n      var newPos = \"\";\n\n      if (!reset && this.options.useOffsetOnTarget) {\n        newPos = this.offset + \"px\";\n      }\n\n      this.target.style.top = newPos;\n    }\n  }, {\n    key: \"respondTo\",\n    value: function respondTo() {\n      if (this.isActive || this.isFrozen) {\n        var parentComputedStyle = window.getComputedStyle(this.options.respondToParent),\n            parentWidth = this.options.respondToParent.getBoundingClientRect().width - parseFloat(parentComputedStyle[\"padding-left\"]) - parseFloat(parentComputedStyle[\"padding-right\"]);\n        this.target.style.width = parentWidth + \"px\";\n      }\n    }\n  }, {\n    key: \"setFrozen\",\n    value: function setFrozen() {\n      this.isFrozen = true;\n      this.target.style.top = Math.abs(this._parentContainerRect.top - this._targetRect.top) + \"px\";\n      this.target.classList.remove(\"fixit--active\");\n      this.target.classList.add(\"fixit--frozen\");\n    }\n  }, {\n    key: \"setBottom\",\n    value: function setBottom() {\n      this.isBottom = true;\n      this.setTargetPos(true);\n      this.target.classList.add(\"fixit--bottom\");\n    }\n  }, {\n    key: \"unsetBottom\",\n    value: function unsetBottom() {\n      this.isBottom = false;\n      this.target.classList.remove(\"fixit--bottom\");\n    }\n  }, {\n    key: \"setIsTall\",\n    value: function setIsTall() {\n      this.isTall = true;\n      this.target.classList.add(\"fixit--is-tall\");\n    }\n  }, {\n    key: \"unsetIsTall\",\n    value: function unsetIsTall() {\n      this.isTall = false;\n      this.target.classList.remove(\"fixit--is-tall\");\n    }\n  }, {\n    key: \"setActive\",\n    value: function setActive(toBottom) {\n      this.isActive = true;\n      this.setPlaceholderProps(!this.options.reversePlaceholderBehavior);\n      this.target.classList.remove(\"fixit--frozen\");\n      this.target.classList.add(\"fixit--active\");\n\n      if (toBottom) {\n        this.setBottom();\n      } else {\n        this.setTargetPos();\n      }\n\n      if (this.options.respondToParent) {\n        this.respondTo();\n      }\n\n      this.publishEvent(\"fixit\", \"active\", this.target, {\n        FixIt: this\n      });\n\n      if (typeof this.options.onActiveCallback === \"function\") {\n        this.options.onActiveCallback(this.target, this);\n      }\n    }\n  }, {\n    key: \"setInactive\",\n    value: function setInactive() {\n      this.isActive = false;\n      this.unsetBottom();\n      this.unsetIsTall();\n      this.setPlaceholderProps(this.options.reversePlaceholderBehavior && this.isEnabled);\n      this.target.classList.remove(\"fixit--active\");\n      this.target.classList.remove(\"fixit--docked\");\n      this.target.classList.remove(\"fixit--frozen\");\n      this.target.classList.remove(\"fixit--scrolled\");\n      this.removeDirectionUpdates();\n      this.scrollPosition = 0;\n\n      if (this.options.useOffsetOnTarget) {\n        this.setTargetPos(true);\n      }\n\n      if (this.options.respondToParent) {\n        this.target.style.width = \"\";\n      }\n\n      this.publishEvent(\"fixit\", \"inactive\", this.target, {\n        FixIt: this\n      });\n\n      if (typeof this.options.onInactiveCallback === \"function\") {\n        this.options.onInactiveCallback(this.target, this);\n      }\n    }\n  }, {\n    key: \"removeDirectionUpdates\",\n    value: function removeDirectionUpdates() {\n      if (this.options.enableDirectionUpdates) {\n        this.target.classList.remove(\"fixit--scroll-\".concat(PROPERTIES.direction.up));\n        this.target.classList.remove(\"fixit--scroll-\".concat(PROPERTIES.direction.down));\n        this.target.classList.remove(\"fixit--scroll-direction-change\");\n        delete this._prevScrollDirection;\n        window.clearTimeout(this._scrollDirectionTimeout);\n      }\n    }\n  }, {\n    key: \"setPlaceholder\",\n    value: function setPlaceholder() {\n      this.placeholder = document.createElement(\"div\");\n      this.placeholder.className = \"fixit-placeholder\";\n      this.target.parentNode.insertBefore(this.placeholder, this.target);\n    }\n  }, {\n    key: \"removePlaceholder\",\n    value: function removePlaceholder() {\n      this.placeholder.parentNode.removeChild(this.placeholder);\n    }\n  }, {\n    key: \"setPlaceholderProps\",\n    value: function setPlaceholderProps(sync) {\n      if (this.placeholder) {\n        if (sync) {\n          this.placeholder.style.height = this._targetRect.height + \"px\";\n          this.placeholder.style.margin = window.getComputedStyle(this.target).margin;\n        } else {\n          this.placeholder.style.height = \"\";\n          this.placeholder.style.margin = \"\";\n        }\n      }\n    }\n  }, {\n    key: \"targetIsTall\",\n    value: function targetIsTall() {\n      return this._targetRect.height + this.offset > document.documentElement.clientHeight;\n    }\n  }, {\n    key: \"getScrollDirection\",\n    value: function getScrollDirection() {\n      if (this.scrollPosition > this._placeholderRect.top) {\n        this.currentScrollDirection = PROPERTIES.direction.down;\n      } else if (this.scrollPosition < this._placeholderRect.top) {\n        this.currentScrollDirection = PROPERTIES.direction.up;\n      }\n\n      this.scrollPosition = this._placeholderRect.top;\n      return this.currentScrollDirection;\n    }\n  }, {\n    key: \"requestScrollDirectionUpdate\",\n    value: function requestScrollDirectionUpdate(newScrollDirection) {\n      this._setScrollDirectionCallCount = (this._setScrollDirectionCallCount || 0) + 1;\n      this._newScrollPosition = this._placeholderRect.top;\n\n      if (this._setScrollDirectionCallCount >= this._scrollDirectionThrottle) {\n        this._updateScrollDirectionOnThreshold(newScrollDirection);\n\n        this._setScrollDirectionCallCount = 0;\n      }\n\n      window.clearTimeout(this._scrollDirectionTimeout);\n      this._scrollDirectionTimeout = window.setTimeout(function () {\n        this._updateScrollDirectionOnThreshold(newScrollDirection);\n\n        this._prevScrollPosition = this._placeholderRect.top;\n      }.bind(this), this._scrollDirectionWait);\n    }\n  }, {\n    key: \"_updateScrollDirectionOnThreshold\",\n    value: function _updateScrollDirectionOnThreshold(newScrollDirection) {\n      this._diffScrollPosition = Math.abs(this._newScrollPosition - (this._prevScrollPosition || 0));\n\n      if (this._diffScrollPosition > this._scrollPositionThereshold) {\n        this.updateScrollDirection(newScrollDirection);\n      }\n    }\n  }, {\n    key: \"updateScrollDirection\",\n    value: function updateScrollDirection(newScrollDirection) {\n      this.publishEvent(\"fixit\", \"scrollDirectionUpdate\", this.target, {\n        previousDirection: this._prevScrollDirection,\n        newDirection: newScrollDirection,\n        FixIt: this\n      });\n\n      if (this._prevScrollDirection !== newScrollDirection) {\n        this.target.classList.add(\"fixit--scroll-\".concat(newScrollDirection));\n        this.target.classList.remove(\"fixit--scroll-\".concat(this._prevScrollDirection));\n\n        if (this._prevScrollDirection) {\n          this.target.classList.add(\"fixit--scroll-direction-change\");\n        }\n\n        this._prevScrollDirection = newScrollDirection;\n        this._prevScrollPosition = this._placeholderRect.top;\n      }\n    }\n  }, {\n    key: \"toggletFullyScrolled\",\n    value: function toggletFullyScrolled(setScrolled) {\n      if (setScrolled) {\n        this.target.classList.add(\"fixit--scrolled\");\n      } else {\n        this.target.classList.remove(\"fixit--scrolled\");\n      }\n    }\n  }, {\n    key: \"publishEvent\",\n    value: function publishEvent(moduleName, eventName, target, detail) {\n      var event,\n          params = {\n        bubbles: true,\n        cancelable: true,\n        detail: detail\n      },\n          eventString = moduleName && eventName ? \"\".concat(moduleName, \":\").concat(eventName) : moduleName || eventName;\n\n      if (typeof window.CustomEvent !== \"function\") {\n        event = document.createEvent(\"CustomEvent\");\n        event.initCustomEvent(eventString, params.bubbles, params.cancelable, null);\n      } else {\n        event = new CustomEvent(eventString, params);\n      }\n\n      target.dispatchEvent(event);\n    }\n  }], [{\n    key: \"getInstance\",\n    value: function getInstance(el) {\n      return INSTANCES.get(el);\n    }\n  }]);\n\n  return FixIt;\n}();\n\nexports[\"default\"] = FixIt;\n\n//# sourceURL=webpack:///./node_modules/@borngroup/born-fixit/dist/born-fixit.min.js?");

/***/ })

}]);