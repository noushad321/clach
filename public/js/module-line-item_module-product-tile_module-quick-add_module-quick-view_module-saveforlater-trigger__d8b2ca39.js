(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["module-line-item~module-product-tile~module-quick-add~module-quick-view~module-saveforlater-trigger~~d8b2ca39"],{

/***/ "./cartridges/app_accelerator_core/cartridge/client/default/js/product/productUtils.js":
/*!*********************************************************************************************!*\
  !*** ./cartridges/app_accelerator_core/cartridge/client/default/js/product/productUtils.js ***!
  \*********************************************************************************************/
/*! exports provided: getChildProducts, getOptions, getPidValue, getProductType, updateSingleID, updatePIDs, updateName, updateImages, updateImageList, updateSingleImage, updateURLs, updateQueryStrings, updateProductPrice, getQuantitySelector, getQuantitySelected, getProductContainer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getChildProducts\", function() { return getChildProducts; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getOptions\", function() { return getOptions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getPidValue\", function() { return getPidValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getProductType\", function() { return getProductType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateSingleID\", function() { return updateSingleID; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updatePIDs\", function() { return updatePIDs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateName\", function() { return updateName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateImages\", function() { return updateImages; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateImageList\", function() { return updateImageList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateSingleImage\", function() { return updateSingleImage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateURLs\", function() { return updateURLs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateQueryStrings\", function() { return updateQueryStrings; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateProductPrice\", function() { return updateProductPrice; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getQuantitySelector\", function() { return getQuantitySelector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getQuantitySelected\", function() { return getQuantitySelected; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getProductContainer\", function() { return getProductContainer; });\n/* harmony import */ var _helpers_urlUtilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/urlUtilities */ \"./cartridges/app_accelerator_core/cartridge/client/default/js/helpers/urlUtilities.js\");\n\n\n\n/**\n * Retrieves the product data from the children of the current container.\n * Used by backend to determine what to add to cart.\n *\n * @return {string[]} - List of selected bundle product item ID's\n */\n\nfunction getChildProducts(container) {\n  var productType = getProductType(container),\n      isProductSet = productType === 'set',\n      productData = [],\n      productList = container.querySelectorAll(\"[data-product-container=\\\"\".concat(productType, \"-item\\\"]\"));\n  [].forEach.call(productList, function (currentItem) {\n    var currentItemQty = getQuantitySelected(currentItem),\n        currentItemData = {\n      pid: getPidValue(currentItem),\n      options: getOptions(currentItem, true)\n    }; //SFCC checks for different properties depending if item is a Product Set or not (quantity vs qty).\n\n    currentItemData[isProductSet ? 'qty' : 'quantity'] = currentItemQty;\n    productData.push(currentItemData);\n  });\n  return {\n    list: productList,\n    data: JSON.stringify(productData)\n  };\n}\n/**\n * Retrieve product options\n *\n * @param {HTMLNodeEl} referenceEl - DOM element to use as a reference to find the closest productConatiner.\n * @return {string} - Product options and their selected values\n */\n\nfunction getOptions(referenceEl, stringify) {\n  var productContainer = getProductContainer(referenceEl),\n      options = [].map.call(productContainer.querySelectorAll('[data-option-id]'), function (currentItem) {\n    var optionsEl = currentItem.querySelector('[data-product-component=\"option-selection\"]'),\n        selectedValueId = optionsEl ? optionsEl.options[optionsEl.selectedIndex].getAttribute('data-value-id') : currentItem.getAttribute('data-option-value-id');\n\n    if (!selectedValueId) {\n      [].map.call(productContainer.querySelectorAll('[data-static-option-id]'), function (currentItem) {\n        if (currentItem.classList.contains('toggle--active')) {\n          selectedValueId = currentItem.getAttribute('data-static-option-id');\n        }\n      });\n    }\n\n    return {\n      optionId: currentItem.getAttribute('data-option-id'),\n      selectedValueId: selectedValueId\n    };\n  });\n  return stringify ? JSON.stringify(options) : options;\n}\n/**\n * Retrieves the relevant Product ID value.\n */\n\nfunction getPidValue(el) {\n  return getProductContainer(el).getAttribute('data-pid');\n}\n/**\n * Retrieves the relevant product type value (pdp, quickview, tile, set, set-item, bundle, bundle-item).\n */\n\nfunction getProductType(el) {\n  return getProductContainer(el).getAttribute('data-product-container');\n}\nfunction updateSingleID(newID, targetEl, productContainer, updateIDText) {\n  //If a `productContainer` is provided, do not update the PIDs for children of sub-products.\n  //This is necessary to prevent a product bundle overriding its items PIDs.\n  if (!productContainer || productContainer === getProductContainer(targetEl)) {\n    targetEl.setAttribute('data-pid', newID);\n\n    if (updateIDText) {\n      targetEl.textContent = newID;\n    }\n  }\n}\nfunction updatePIDs(newID, productContainer) {\n  updateSingleID(newID, productContainer);\n  [].forEach.call(productContainer.querySelectorAll('[data-pid]'), function (currentEl) {\n    return updateSingleID(newID, currentEl, productContainer);\n  });\n  [].forEach.call(productContainer.querySelectorAll('[data-product-component=\"pid\"]'), function (currentEl) {\n    return updateSingleID(newID, currentEl, productContainer, true);\n  });\n}\n/**\n * Update any matches of \"[data-product-component=\"name\"]\" within a `productContainer` with the `newName` value.\n */\n\nfunction updateName(newName, productContainer) {\n  [].forEach.call(productContainer.querySelectorAll('[data-product-component=\"name\"]'), function (currentEl) {\n    return currentEl.innerHTML = newName;\n  });\n}\n/**\n * Update the product images elements with the provided `responseImages`.\n * @param  {Array} responseImages          [List of images that the view should be updated with]\n * @param  {HTMLElement} productContainer  [The container for the product. Provides context for image selection]\n * @param  {String} imageSelector          [The image selector to use to get a give image list.]\n * @param  {Boolean} updateImageDifference [If TRUE, updates the view so that it matches the amount of images available in `responseImages`]\n */\n\nfunction updateImages(responseImages, productContainer) {\n  var imageSelector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '[data-product-component*=\"image\"]';\n  var updateImageDifference = arguments.length > 3 ? arguments[3] : undefined;\n\n  if (updateImageDifference) {\n    updateImageList(responseImages, productContainer);\n  }\n\n  [].forEach.call(productContainer.querySelectorAll(imageSelector), function (currentEl) {\n    updateSingleImage(responseImages[currentEl.getAttribute('data-image-index')], currentEl);\n  });\n}\n/**\n * Checks wether the `responseImages` object matches the current list of viewable images.\n * If it doesn't, updates the view so that viewable images are displayed or hidden.\n */\n\nfunction updateImageList(responseImages, productContainer) {\n  var imageCarousels = productContainer.querySelectorAll('[data-product-component*=\"-gallery\"]');\n  [].forEach.call(imageCarousels, function (imageCarousel) {\n    var imageCarouselConfig = imageCarousel.hasAttribute('data-carousel-config') ? $(imageCarousel).slick('getSlick') : null,\n        carouselEnabled = imageCarouselConfig && !imageCarouselConfig.unslicked,\n        imageCarouselLength = carouselEnabled ? imageCarouselConfig.slideCount : imageCarousel.childElementCount,\n        imageCountDifference = Math.abs(responseImages.length - imageCarouselLength),\n        hasNewImages = responseImages.length > imageCarouselLength; //Loop through however many counts of images are either missing or additional.\n\n    for (var i = 0; i < imageCountDifference; i++) {\n      //If there are missing images, clone the image template and insert it in the current gallery container.\n      if (hasNewImages) {\n        var imageTemplate = productContainer.querySelector(\"[data-image-template=\\\"\".concat(imageCarousel.getAttribute('data-product-component'), \"\\\"]\")).cloneNode(true);\n        imageTemplate.querySelector('[data-image-index]').setAttribute('data-image-index', imageCarouselLength++);\n        imageTemplate.removeAttribute('data-image-template'); //Either use the native `appendChild` or the carousel's \"add\" method to insert the new images.\n\n        if (carouselEnabled) {\n          $(imageCarousel).slick('slickAdd', imageTemplate);\n        } else {\n          imageCarousel.appendChild(imageTemplate);\n        }\n      } else {\n        //If there are additional images in the DOM, remove them.\n        //Check wether or not there's a carousel enabled before removing the elements.\n        if (carouselEnabled) {\n          $(imageCarousel).slick('slickRemove', --imageCarouselLength);\n        } else {\n          imageCarousel.removeChild(imageCarousel.lastElementChild);\n        }\n      }\n    }\n\n    $('body').trigger('product:imageListUpdate', {\n      container: productContainer,\n      imageContainer: imageCarousel,\n      type: imageCarousel.getAttribute('data-product-component')\n    });\n  });\n}\nfunction updateSingleImage(currentImgObj, currentImgEl) {\n  if (currentImgObj) {\n    currentImgEl.src = currentImgObj.url;\n    currentImgEl.title = currentImgObj.title;\n    currentImgEl.alt = currentImgObj.alt;\n  }\n}\n/**\n * Update URLs within the provided `productContainer`.\n * Elements matching the `[data-product-url]` selector will get their `.href` property updated.\n * @param  {[type]} newURL           [The desired new URL]\n * @param  {[type]} productContainer [The target container]\n */\n\nfunction updateURLs(newURL, productContainer) {\n  var urlEls = productContainer.querySelectorAll('[data-product-url]'),\n      queryParams = Object(_helpers_urlUtilities__WEBPACK_IMPORTED_MODULE_0__[\"getQueryStringParams\"])(newURL);\n  [].forEach.call(urlEls, function (currentEl) {\n    var urlType = currentEl.getAttribute('data-product-url'),\n        //A URL \"type\" may be set in the 'data-product-url' attribute.\n    //When available, it will look in `window.SFRA.Urls` for a URL type match.\n    //This is useful for when you need to update several URLs within a container\n    //that may target different Product presentation views, for example a PDP, QuickView, or QuickAdd, etc.\n    updatedURL = urlType ? Object(_helpers_urlUtilities__WEBPACK_IMPORTED_MODULE_0__[\"appendParamsToURL\"])(window.SFRA.Urls[urlType], queryParams) : newURL;\n\n    if (currentEl.tagName === 'A') {\n      currentEl.href = updatedURL;\n    } else {\n      currentEl.setAttribute('data-url', updatedURL);\n    }\n  });\n}\n/**\n * Updates matching elements with the new querystring value.\n * This value is used for things like easy requesting data from the current product configuration on demand, like loading a zoom modal.\n * @param  {[type]} newQueryString   [description]\n * @param  {[type]} productContainer [description]\n */\n\nfunction updateQueryStrings(newQueryString, productContainer) {\n  productContainer.setAttribute('data-product-querystring', newQueryString);\n}\n/**\n * Updates the current product's price with the provided HTML.\n */\n\nfunction updateProductPrice(productContainer, product) {\n  var priceEl = productContainer.querySelector('[data-product-component=\"price\"]'),\n      priceTaxEl = $('[data-product-component=\"pdp-price-tax-element\"]');\n  priceTaxEl.addClass('hidden');\n\n  if (product && priceEl) {\n    priceEl.outerHTML = product.price.html;\n\n    if (product.available && product.sellable && product.price && product.price.type !== 'range' && product.price.sales && product.price.sales.value) {\n      priceTaxEl.removeClass('hidden');\n    }\n  }\n}\n/**\n * Retrieve contextual quantity selector\n * @param {jquery} $el - DOM container for the relevant quantity\n * @return {jquery} - quantity selector DOM container\n */\n\nfunction getQuantitySelector(el) {\n  return getProductContainer(el).querySelector('[data-product-component=\"qty\"]');\n}\n/**\n * Retrieves the value associated with the Quantity pull-down menu\n * @param {jquery} $el - DOM container for the relevant quantity\n * @return {string} - value found in the quantity input\n */\n\nfunction getQuantitySelected(el) {\n  var quantitySelector = getQuantitySelector(el);\n  return quantitySelector ? quantitySelector.value : 1;\n}\nfunction getProductContainer(el) {\n  return el.closest('[data-product-container]');\n}\n\n//# sourceURL=webpack:///./cartridges/app_accelerator_core/cartridge/client/default/js/product/productUtils.js?");

/***/ })

}]);