(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["module-page-motion"],{

/***/ "./cartridges/app_accelerator_core/cartridge/client/default/js/modules/module.page-motion.js":
/*!***************************************************************************************************!*\
  !*** ./cartridges/app_accelerator_core/cartridge/client/default/js/modules/module.page-motion.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return PageMotion; });\n/* harmony import */ var scrollmonitor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! scrollmonitor */ \"./node_modules/scrollmonitor/scrollMonitor.js\");\n/* harmony import */ var scrollmonitor__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(scrollmonitor__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _helpers_utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/utilities */ \"./cartridges/app_accelerator_core/cartridge/client/default/js/helpers/utilities.js\");\n/* harmony import */ var _borngroup_born_utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @borngroup/born-utilities */ \"./node_modules/@borngroup/born-utilities/dist/born-utilities.min.js\");\n/* harmony import */ var _borngroup_born_utilities__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_borngroup_born_utilities__WEBPACK_IMPORTED_MODULE_2__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n/**\n * Adds special handling to elements to display different types of motion.\n * Timing is mostly handled on the JS, while actual transitions are carried over on CSS.\n */\n\nvar PageMotion = /*#__PURE__*/function () {\n  function PageMotion(options) {\n    _classCallCheck(this, PageMotion);\n\n    this.motionInterval = 100;\n    this.elementOffset = -100;\n    Object(_borngroup_born_utilities__WEBPACK_IMPORTED_MODULE_2__[\"callbackOnElements\"])(options.elements, this._setupMotionEls.bind(this));\n  }\n\n  _createClass(PageMotion, [{\n    key: \"_setupMotionEls\",\n    value: function _setupMotionEls(currentPageEl) {\n      this._getElementArrays(currentPageEl);\n\n      currentPageEl.classList.add('set--page-motion-ready');\n\n      this._triggerMotionInterval(this.inViewElements);\n    }\n    /**\n     * Gets the in-view and out-view elements and sets them in arrays easy access.\n     * @param  {[type]} currentPageEl [description]\n     * @return {[type]}               [description]\n     */\n\n  }, {\n    key: \"_getElementArrays\",\n    value: function _getElementArrays(currentPageEl) {\n      var motionEls = currentPageEl.querySelectorAll('[data-motion]');\n\n      this._removeWatchers();\n\n      this.inViewElements = [];\n      this.outViewElements = [];\n      [].forEach.call(motionEls, function (currentMotionEl, index) {\n        //Remove any motion attributes from elements that are semantically hidden (think Slick cloned slides).\n        //This prevents waiting for animations or displaying blank containers.\n        if (currentMotionEl.closest('[aria-hidden=\"true\"]')) {\n          currentMotionEl.removeAttribute('data-motion');\n          return;\n        } else {\n          var motionWatcher = scrollmonitor__WEBPACK_IMPORTED_MODULE_0___default.a.create(currentMotionEl, this.elementOffset),\n              motionData = this.getMotionData(currentMotionEl, motionWatcher),\n              //This might not be the best way to check for visibility, but it works for now.\n          //Need to count only which elements are currently visible, the other elements can be shown on scroll.\n          elementIsVisible = currentMotionEl.offsetParent || currentMotionEl.firstElementChild && currentMotionEl.firstElementChild.offsetHeight > 0;\n\n          this._setMotionData(currentMotionEl, motionData, true);\n\n          this._setupMotionElChildren(currentMotionEl, motionData);\n\n          if (motionWatcher.isInViewport && elementIsVisible || motionData.immediate) {\n            //Push currently visible elements into an array,\n            //which is later used to display motion in a set interval.\n            this.inViewElements.push(currentMotionEl);\n          } else {\n            //For the out-of-view elements, push scrollMonitor watchers into an array.\n            //Scale motion should always trigger automatically and not with scroll.\n            if (!motionData.hasScaleMotion) {\n              this.outViewElements.push(motionWatcher);\n            }\n\n            motionWatcher.one('enterViewport', this._enterViewportDebouncer.bind(this, currentMotionEl, index));\n          }\n        }\n      }.bind(this));\n    }\n    /**\n     * Debounces scrollMonitor's \"enterViewport\" event.\n     * Pushes all newly \"in viewport\" elements into an array,\n     * which is then passed to _triggerMotionInterval()\n     * so that motion is triggered in the specified interval.\n     * If this is not in place, motion will trigger at the same time\n     * for elements that just entered the viewort.\n     */\n\n  }, {\n    key: \"_enterViewportDebouncer\",\n    value: function _enterViewportDebouncer(currentMotionEl, orderPreference) {\n      this.enterViewportEls = this.enterViewportEls || []; //Force the DOM order on the array.\n      //`orderPreference` comes from the position in the DOM.\n      //scrollMonitor sometimes fires in the wrong order when multiple elements are at the same height.\n\n      this.enterViewportEls[orderPreference] = currentMotionEl;\n      window.clearTimeout(this.enterViewportTimeout);\n      this.enterViewportTimeout = window.setTimeout(function () {\n        //Clean array out of empty items.\n        this.enterViewportEls = this.enterViewportEls.filter(function (n) {\n          return n;\n        });\n\n        this._triggerMotionInterval(this.enterViewportEls, true); //Empty array after it has been passed to _triggerMotionInterval() to avoid looping through the same elements again.\n\n\n        this.enterViewportEls = [];\n      }.bind(this), 25);\n    }\n    /**\n     * Ensures watchers are destroyed in case the `this.outViewElements` array needs to be rebuilt.\n     */\n\n  }, {\n    key: \"_removeWatchers\",\n    value: function _removeWatchers() {\n      if (this.outViewElements) {\n        this.outViewElements.forEach(function (watchedElement) {\n          return watchedElement.destroy;\n        });\n      }\n    }\n    /**\n     * Facilitates applying similar motion to a list of matching children elements.\n     * This is also better than manually setting data-motion properties, because doing so would pause\n     * full page transitions if the list of a data-motion children is too long.\n     * @param  {[type]} motionEl   [description]\n     * @param  {[type]} motionData [description]\n     */\n\n  }, {\n    key: \"_setupMotionElChildren\",\n    value: function _setupMotionElChildren(motionEl, motionData) {\n      if (motionData.children) {\n        [].forEach.call(motionData.children, function (currentChild) {\n          currentChild.setAttribute('data-motion', motionData.propertiesArray.join(' '));\n\n          this._setMotionData(currentChild, motionData, false);\n        }.bind(this));\n      }\n    }\n    /**\n     * Very silly JSON string test. It just checks if the first character is an opening bracket,\n     * because really that's all we need.\n     */\n\n  }, {\n    key: \"getMotionData\",\n    value: function getMotionData(motionEl, motionWatcher) {\n      var motionData = {},\n          motionString = motionEl.getAttribute('data-motion'),\n          propertiesString;\n\n      if (motionString.charAt(0) === '{') {\n        var parsedData = JSON.parse(motionString);\n        motionData = parsedData;\n        propertiesString = parsedData.properties;\n\n        if (parsedData.children) {\n          motionData.children = motionEl.querySelectorAll(parsedData.children);\n        }\n      } else {\n        propertiesString = motionString;\n      }\n\n      motionData.propertiesArray = propertiesString.split(/(?:,| )+/);\n      motionData.hasScaleMotion = propertiesString.indexOf('scale-') !== -1;\n\n      this._setDirectionProperty(motionWatcher, motionData.propertiesArray);\n\n      return motionData;\n    }\n    /**\n     * Updates the \"from-<direction>\" property of a watched element with the direction based on the element's position in the DOM.\n     * Leverages ScrollMonitor's data to determine where the element is positioned.\n     */\n\n  }, {\n    key: \"_setDirectionProperty\",\n    value: function _setDirectionProperty(motionWatcher) {\n      var propertiesArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'from-v-direction';\n      var directionIndex = propertiesArray.indexOf(direction);\n\n      if (directionIndex !== -1 && direction === 'from-v-direction') {\n        propertiesArray[directionIndex] = motionWatcher.isInViewport || motionWatcher.isBelowViewport ? 'from-bottom' : 'from-top';\n      }\n    }\n    /**\n     * Sets the motionData properties into a targetEl (either an element with data-motion or a defined child).\n     * @param {[type]} targetEl    [description]\n     * @param {[type]} motionData  [description]\n     * @param {[type]} setChildren [description]\n     */\n\n  }, {\n    key: \"_setMotionData\",\n    value: function _setMotionData(targetEl, motionData, setChildren) {\n      targetEl.motionSettings = targetEl.motionSettings || {\n        motionCompleteHandler: this._motionCompleteHandler,\n        propertiesArray: motionData.propertiesArray.slice(0),\n        //Slice array to create independent array references to elements and their children.\n        children: setChildren && motionData.children ? motionData.children : '',\n        scrollTracking: motionData.scrollTracking\n      };\n      PageMotion.toggleMotionClasses(targetEl, true);\n    }\n    /**\n     * Fires the initial motion by setting a \"set--motion-trigger\" class, which has CSS transitions set.\n     * @param  {[type]} motionEl [description]\n     * @return {[type]}          [description]\n     */\n\n  }, {\n    key: \"triggerMotion\",\n    value: function triggerMotion(motionEl) {\n      motionEl.classList.add('set--motion-trigger');\n\n      this._triggerChildrenMotion(motionEl);\n\n      motionEl.addEventListener(Object(_borngroup_born_utilities__WEBPACK_IMPORTED_MODULE_2__[\"whichTransition\"])(), motionEl.motionSettings.motionCompleteHandler);\n    }\n  }, {\n    key: \"_triggerChildrenMotion\",\n    value: function _triggerChildrenMotion(motionEl) {\n      //Fire children motions, if any.\n      if (motionEl.motionSettings.children) {\n        this._triggerMotionInterval(motionEl.motionSettings.children);\n      }\n    }\n    /**\n     * Forces elements to display a motion in a set interval.\n     * The alternative, `window.setTimeout`, causes issues because browsers attempt to\n     * reduce the amount of timers running at the same time.\n     * @param  {NodeList} elementList [description]\n     */\n\n  }, {\n    key: \"_triggerMotionInterval\",\n    value: function _triggerMotionInterval(elementList) {\n      var self = this,\n          intervalCounter = 0,\n          pageLoadInterval;\n      pageLoadInterval = window.setInterval(function () {\n        if (elementList[intervalCounter]) {\n          self.triggerMotion(elementList[intervalCounter]);\n          intervalCounter++;\n        } else {\n          window.clearInterval(pageLoadInterval);\n        }\n      }, self.motionInterval);\n    }\n    /**\n     * After either an initial data-motion (or its children) element transition is complete,\n     * reset said element to its original state to prevent issues with user-actionable transitions.\n     * @param  {[type]} evt [description]\n     */\n\n  }, {\n    key: \"_motionCompleteHandler\",\n    value: function _motionCompleteHandler(evt) {\n      if (evt.target === this) {\n        this.removeAttribute('data-motion');\n        this.classList.add('set--motion-complete');\n        this.classList.remove('set--motion-trigger');\n        PageMotion.toggleMotionClasses(this);\n        Object(_helpers_utilities__WEBPACK_IMPORTED_MODULE_1__[\"publishEvent\"])('motion', 'complete', this);\n        this.removeEventListener(Object(_borngroup_born_utilities__WEBPACK_IMPORTED_MODULE_2__[\"whichTransition\"])(), this.motionSettings.motionCompleteHandler);\n      }\n    }\n    /**\n     * Sets motion classes on the target element depending on the motion types defined on its `data-motion` attribute.\n     * @param  {[type]} targetEl [description]\n     * @param  {[type]} add      [description]\n     */\n\n  }], [{\n    key: \"toggleMotionClasses\",\n    value: function toggleMotionClasses(targetEl, add) {\n      targetEl.motionSettings.propertiesArray.forEach(function (currentMotion) {\n        if (add) {\n          targetEl.classList.add(\"set--motion-\".concat(currentMotion));\n        } else {\n          targetEl.classList.remove(\"set--motion-\".concat(currentMotion));\n        }\n      });\n    }\n  }]);\n\n  return PageMotion;\n}();\n\n\n\n//# sourceURL=webpack:///./cartridges/app_accelerator_core/cartridge/client/default/js/modules/module.page-motion.js?");

/***/ }),

/***/ "./node_modules/scrollmonitor/scrollMonitor.js":
/*!*****************************************************!*\
  !*** ./node_modules/scrollmonitor/scrollMonitor.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!function(t,e){ true?module.exports=e():undefined}(this,function(){return function(t){function e(o){if(i[o])return i[o].exports;var s=i[o]={exports:{},id:o,loaded:!1};return t[o].call(s.exports,s,s.exports,e),s.loaded=!0,s.exports}var i={};return e.m=t,e.c=i,e.p=\"\",e(0)}([function(t,e,i){\"use strict\";var o=i(1),s=o.isInBrowser,n=i(2),r=new n(s?document.body:null);r.setStateFromDOM(null),r.listenToDOM(),s&&(window.scrollMonitor=r),t.exports=r},function(t,e){\"use strict\";e.VISIBILITYCHANGE=\"visibilityChange\",e.ENTERVIEWPORT=\"enterViewport\",e.FULLYENTERVIEWPORT=\"fullyEnterViewport\",e.EXITVIEWPORT=\"exitViewport\",e.PARTIALLYEXITVIEWPORT=\"partiallyExitViewport\",e.LOCATIONCHANGE=\"locationChange\",e.STATECHANGE=\"stateChange\",e.eventTypes=[e.VISIBILITYCHANGE,e.ENTERVIEWPORT,e.FULLYENTERVIEWPORT,e.EXITVIEWPORT,e.PARTIALLYEXITVIEWPORT,e.LOCATIONCHANGE,e.STATECHANGE],e.isOnServer=\"undefined\"==typeof window,e.isInBrowser=!e.isOnServer,e.defaultOffsets={top:0,bottom:0}},function(t,e,i){\"use strict\";function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function s(t){return c?0:t===document.body?window.innerHeight||document.documentElement.clientHeight:t.clientHeight}function n(t){return c?0:t===document.body?Math.max(document.body.scrollHeight,document.documentElement.scrollHeight,document.body.offsetHeight,document.documentElement.offsetHeight,document.documentElement.clientHeight):t.scrollHeight}function r(t){return c?0:t===document.body?window.pageYOffset||document.documentElement&&document.documentElement.scrollTop||document.body.scrollTop:t.scrollTop}var h=i(1),c=h.isOnServer,a=h.isInBrowser,l=h.eventTypes,p=i(3),u=!1;if(a)try{var w=Object.defineProperty({},\"passive\",{get:function(){u=!0}});window.addEventListener(\"test\",null,w)}catch(t){}var d=!!u&&{capture:!1,passive:!0},f=function(){function t(e,i){function h(){if(a.viewportTop=r(e),a.viewportBottom=a.viewportTop+a.viewportHeight,a.documentHeight=n(e),a.documentHeight!==p){for(u=a.watchers.length;u--;)a.watchers[u].recalculateLocation();p=a.documentHeight}}function c(){for(w=a.watchers.length;w--;)a.watchers[w].update();for(w=a.watchers.length;w--;)a.watchers[w].triggerCallbacks()}o(this,t);var a=this;this.item=e,this.watchers=[],this.viewportTop=null,this.viewportBottom=null,this.documentHeight=n(e),this.viewportHeight=s(e),this.DOMListener=function(){t.prototype.DOMListener.apply(a,arguments)},this.eventTypes=l,i&&(this.containerWatcher=i.create(e));var p,u,w;this.update=function(){h(),c()},this.recalculateLocations=function(){this.documentHeight=0,this.update()}}return t.prototype.listenToDOM=function(){a&&(window.addEventListener?(this.item===document.body?window.addEventListener(\"scroll\",this.DOMListener,d):this.item.addEventListener(\"scroll\",this.DOMListener,d),window.addEventListener(\"resize\",this.DOMListener)):(this.item===document.body?window.attachEvent(\"onscroll\",this.DOMListener):this.item.attachEvent(\"onscroll\",this.DOMListener),window.attachEvent(\"onresize\",this.DOMListener)),this.destroy=function(){window.addEventListener?(this.item===document.body?(window.removeEventListener(\"scroll\",this.DOMListener,d),this.containerWatcher.destroy()):this.item.removeEventListener(\"scroll\",this.DOMListener,d),window.removeEventListener(\"resize\",this.DOMListener)):(this.item===document.body?(window.detachEvent(\"onscroll\",this.DOMListener),this.containerWatcher.destroy()):this.item.detachEvent(\"onscroll\",this.DOMListener),window.detachEvent(\"onresize\",this.DOMListener))})},t.prototype.destroy=function(){},t.prototype.DOMListener=function(t){this.setStateFromDOM(t)},t.prototype.setStateFromDOM=function(t){var e=r(this.item),i=s(this.item),o=n(this.item);this.setState(e,i,o,t)},t.prototype.setState=function(t,e,i,o){var s=e!==this.viewportHeight||i!==this.contentHeight;if(this.latestEvent=o,this.viewportTop=t,this.viewportHeight=e,this.viewportBottom=t+e,this.contentHeight=i,s)for(var n=this.watchers.length;n--;)this.watchers[n].recalculateLocation();this.updateAndTriggerWatchers(o)},t.prototype.updateAndTriggerWatchers=function(t){for(var e=this.watchers.length;e--;)this.watchers[e].update();for(e=this.watchers.length;e--;)this.watchers[e].triggerCallbacks(t)},t.prototype.createCustomContainer=function(){return new t},t.prototype.createContainer=function(e){\"string\"==typeof e?e=document.querySelector(e):e&&e.length>0&&(e=e[0]);var i=new t(e,this);return i.setStateFromDOM(),i.listenToDOM(),i},t.prototype.create=function(t,e){\"string\"==typeof t?t=document.querySelector(t):t&&t.length>0&&(t=t[0]);var i=new p(this,t,e);return this.watchers.push(i),i},t.prototype.beget=function(t,e){return this.create(t,e)},t}();t.exports=f},function(t,e,i){\"use strict\";function o(t,e,i){function o(t,e){if(0!==t.length)for(E=t.length;E--;)y=t[E],y.callback.call(s,e,s),y.isOne&&t.splice(E,1)}var s=this;this.watchItem=e,this.container=t,i?i===+i?this.offsets={top:i,bottom:i}:this.offsets={top:i.top||w.top,bottom:i.bottom||w.bottom}:this.offsets=w,this.callbacks={};for(var d=0,f=u.length;d<f;d++)s.callbacks[u[d]]=[];this.locked=!1;var m,v,b,I,E,y;this.triggerCallbacks=function(t){switch(this.isInViewport&&!m&&o(this.callbacks[r],t),this.isFullyInViewport&&!v&&o(this.callbacks[h],t),this.isAboveViewport!==b&&this.isBelowViewport!==I&&(o(this.callbacks[n],t),v||this.isFullyInViewport||(o(this.callbacks[h],t),o(this.callbacks[a],t)),m||this.isInViewport||(o(this.callbacks[r],t),o(this.callbacks[c],t))),!this.isFullyInViewport&&v&&o(this.callbacks[a],t),!this.isInViewport&&m&&o(this.callbacks[c],t),this.isInViewport!==m&&o(this.callbacks[n],t),!0){case m!==this.isInViewport:case v!==this.isFullyInViewport:case b!==this.isAboveViewport:case I!==this.isBelowViewport:o(this.callbacks[p],t)}m=this.isInViewport,v=this.isFullyInViewport,b=this.isAboveViewport,I=this.isBelowViewport},this.recalculateLocation=function(){if(!this.locked){var t=this.top,e=this.bottom;if(this.watchItem.nodeName){var i=this.watchItem.style.display;\"none\"===i&&(this.watchItem.style.display=\"\");for(var s=0,n=this.container;n.containerWatcher;)s+=n.containerWatcher.top-n.containerWatcher.container.viewportTop,n=n.containerWatcher.container;var r=this.watchItem.getBoundingClientRect();this.top=r.top+this.container.viewportTop-s,this.bottom=r.bottom+this.container.viewportTop-s,\"none\"===i&&(this.watchItem.style.display=i)}else this.watchItem===+this.watchItem?this.watchItem>0?this.top=this.bottom=this.watchItem:this.top=this.bottom=this.container.documentHeight-this.watchItem:(this.top=this.watchItem.top,this.bottom=this.watchItem.bottom);this.top-=this.offsets.top,this.bottom+=this.offsets.bottom,this.height=this.bottom-this.top,void 0===t&&void 0===e||this.top===t&&this.bottom===e||o(this.callbacks[l],null)}},this.recalculateLocation(),this.update(),m=this.isInViewport,v=this.isFullyInViewport,b=this.isAboveViewport,I=this.isBelowViewport}var s=i(1),n=s.VISIBILITYCHANGE,r=s.ENTERVIEWPORT,h=s.FULLYENTERVIEWPORT,c=s.EXITVIEWPORT,a=s.PARTIALLYEXITVIEWPORT,l=s.LOCATIONCHANGE,p=s.STATECHANGE,u=s.eventTypes,w=s.defaultOffsets;o.prototype={on:function(t,e,i){switch(!0){case t===n&&!this.isInViewport&&this.isAboveViewport:case t===r&&this.isInViewport:case t===h&&this.isFullyInViewport:case t===c&&this.isAboveViewport&&!this.isInViewport:case t===a&&this.isInViewport&&this.isAboveViewport:if(e.call(this,this.container.latestEvent,this),i)return}if(!this.callbacks[t])throw new Error(\"Tried to add a scroll monitor listener of type \"+t+\". Your options are: \"+u.join(\", \"));this.callbacks[t].push({callback:e,isOne:i||!1})},off:function(t,e){if(!this.callbacks[t])throw new Error(\"Tried to remove a scroll monitor listener of type \"+t+\". Your options are: \"+u.join(\", \"));for(var i,o=0;i=this.callbacks[t][o];o++)if(i.callback===e){this.callbacks[t].splice(o,1);break}},one:function(t,e){this.on(t,e,!0)},recalculateSize:function(){this.height=this.watchItem.offsetHeight+this.offsets.top+this.offsets.bottom,this.bottom=this.top+this.height},update:function(){this.isAboveViewport=this.top<this.container.viewportTop,this.isBelowViewport=this.bottom>this.container.viewportBottom,this.isInViewport=this.top<this.container.viewportBottom&&this.bottom>this.container.viewportTop,this.isFullyInViewport=this.top>=this.container.viewportTop&&this.bottom<=this.container.viewportBottom||this.isAboveViewport&&this.isBelowViewport},destroy:function(){var t=this.container.watchers.indexOf(this),e=this;this.container.watchers.splice(t,1);for(var i=0,o=u.length;i<o;i++)e.callbacks[u[i]].length=0},lock:function(){this.locked=!0},unlock:function(){this.locked=!1}};for(var d=function(t){return function(e,i){this.on.call(this,t,e,i)}},f=0,m=u.length;f<m;f++){var v=u[f];o.prototype[v]=d(v)}t.exports=o}])});\n//# sourceMappingURL=scrollMonitor.js.map\n\n//# sourceURL=webpack:///./node_modules/scrollmonitor/scrollMonitor.js?");

/***/ })

}]);